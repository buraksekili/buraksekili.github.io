<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Working with Custom Data Format in Rust using serde | Burak Sekili</title>
<meta name="keywords" content="Rust, serde">
<meta name="description" content="How to serialize and deserialize a custom custom data format in Rust using serde">
<meta name="author" content="Burak Sekili">
<link rel="canonical" href="https://buraksekili.github.io/articles/rust-serde/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.402aea8fcb16ea8922c350ac4593eaa9cc13e6c01b2c0f5fc06b1c73f528c213.css" integrity="sha256-QCrqj8sW6okiw1CsRZPqqcwT5sAbLA9fwGscc/UowhM=" rel="preload stylesheet" as="style">

<link rel="stylesheet" href="css/extended/custom.css">
<link rel="icon" href="https://buraksekili.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://buraksekili.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://buraksekili.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://buraksekili.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://buraksekili.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://buraksekili.github.io/articles/rust-serde/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  
    
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-M6ZJTX7HVG"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-M6ZJTX7HVG');
        }
      </script>
    
  

<meta property="og:title" content="Working with Custom Data Format in Rust using serde" />
<meta property="og:description" content="How to serialize and deserialize a custom custom data format in Rust using serde" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://buraksekili.github.io/articles/rust-serde/" /><meta property="article:section" content="articles" />
<meta property="article:published_time" content="2024-08-23T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-08-23T16:30:50+03:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Working with Custom Data Format in Rust using serde"/>
<meta name="twitter:description" content="How to serialize and deserialize a custom custom data format in Rust using serde"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Articles",
      "item": "https://buraksekili.github.io/articles/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Working with Custom Data Format in Rust using serde",
      "item": "https://buraksekili.github.io/articles/rust-serde/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Working with Custom Data Format in Rust using serde",
  "name": "Working with Custom Data Format in Rust using serde",
  "description": "How to serialize and deserialize a custom custom data format in Rust using serde",
  "keywords": [
    "Rust", "serde"
  ],
  "articleBody": "Working with Custom Data Format in Rust using serde If you need to perform serialization or deserialization in Rust, you’ve most likely used the serde before. I’m currently learning Rust, and I found myself needing similar thing.\nTo get familiar with the Rust ecosystem, I decided to develop a simple key-value store. Initially, the engine for this key-value store was designed to work with JSON objects, as JSON is a widely-used format that’s straightforward to use with web clients. Also, as most of the languages and platforms already support JSON, it is a good choice to start with.\nWhat I wanted to achieve was that users send JSON objects to indicate their request, such as “give me the value of key ”, which can be represented as { \"key\": \"some_key\" } in JSON. The response is also formatted as a JSON object, like {\"value\": \"value_of_the_key\"}. The concept and requirements of this server are quite simple and clear.\nI generally use Go for my projects, where the JSON serialization/deserialization process is straightforward. You can manage it with some tags on your struct, and the rest is handled by Go itself. In Rust, achieving the same thing is also straightforward with serde. You only need to add a few macros, and serde will automatically implement serialization and deserialization methods for you. As JSON is one of the most popular data formats, you can set this up with just a few lines of code. I am not going to give details about how to achieve this as serde documentation has handful examples regarding this.\nAfter checking similar projects, I realized that most of the engines do not use these widely adopted data formats in place with their storage engine. Of course, the reasons of this may vary but the fundamental concerns are more or less the same: performance and simplicity. In my case, users only get, set or rm the key. So, using JSON is a bit overkill here. I totally agree that it is quite straightforward to implement and get start with JSON but what happens if I want to introduce a simple - and to be honest useless and dumbest - data format to interact with my key-value storage engine? Considering that my learning purpose of Rust, the idea looks okay to me.\nThen, I started to focus on how to work with custom data format with serde? So that I can serialize Rust data types to my data format and deserialize some byte sequence such as strings back to Rust types?\nConcepts Before jumping into implementation details, it’d be better to get familiar with some core concepts that we are going to be using.\nData Format First things first, let’s try to understand what the data format is. Simply put, a data format defines how the data is stored and structured. For example, well-known data formats such as JSON, CSV, and TOML can store the same data but in different ways.\nYou probably use these formats on a daily basis as they are widely adopted and used. Almost every language support these data formats more or less. Although these formats use different syntax while representing the data, the underlying data they represent is the same.\nIn my case, I wanted to introduce a simple custom data format, which looks like this:\n\\r: : This format allows me to store a sequence of commands - essentially the requests that users send to the key-value engine, such as fetching a key - in a log file. This format is of course not complicated and maybe even not quite helpful compared to JSON but it is of course cleaner and easier for me to work with. For instance, using this format makes it easy for my parser to determine where a command request starts in the file, as each command is prefixed with \\r: and ends with a colon :.\nThis data format of course is NOT a JSON (or YAML, CSV and whatever) which means I cannot use existing deserializer of already knowns data formats. This means I need to implement my own basic serializer and deserializer to convert Rust data structures, such as enum or struct, into this custom format and vice versa.\nFor simple use cases like mine, you do not even need to write a full Serializer and Deserializer using serde. You can implement a custom deserialize method and a visitor to handle most tasks. My primary goal in creating these custom serializers and deserializers is to learn and understand the process better.\nData Type The data types refer to the way data is stored in memory and classified in the language that we use. In Rust and in many other languages, data types can be simple types such as integers, floating number, booleans and composite ones like structs, enums, and classes.\nOn the other hand, data format is how this data type is stored and structured in the storage.\nFor example, the following Get struct in Rust corresponds to the data type:\n1 2 3 struct Get { key: String, } where, storing this data type as a JSON string as {\"key\": \"some_key\"} is the data format.\nSerialization and Deserialization With that being said, serialization is the process of converting or transforming these data types into a specific data format. For example, if you use a JSON serializer, it will convert your Rust data types into a JSON compatible string representation.\nThe deserialization is kind of the reverse process of the serialization where it takes your input (like as a string, byte sequence or in binary) and converts this input back into the data types, which might be struct or vector etc.\nSerialization As clearly mentioned in serde documentation, serde is NOT a parsing library. So, i am not going to dive into how to parse the stream.\nIn our case, the request that users send is represented as enum type, as follows:\n1 2 3 4 5 pub enum Request { Get { key: String }, Set { key: String, val: String }, Rm { key: String }, } First start with serializing this data type into our custom data format:\n\\r: : In order to serialize our enum, we need to implement Serialize trait for our Request type. This trait only has one required method called serialize. For most of the time, you do not need to implement the trait from scratch. There is a helper procedural macro called serde_derive to implement the trait for you. So, let’s add this macro to our type.\n1 2 3 4 5 6 7 8 use serde::Serialize; #[derive(Serialize)] pub enum Request { Get { key: String }, Set { key: String, val: String }, Rm { key: String }, } Eventually, this macro generates the following code (which shows the generated code in simplified manner) for Request struct.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // for more, please check https://docs.rs/serde/1.0.208/serde/ser/trait.Serialize.html impl Serialize for Request { fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e where S: Serializer, { match *self { Request::Get { ref key } =\u003e { let mut s = serializer.serialize_struct_variant(\"Request\", 0, \"Get\", 1)?; s.serialize_field(\"key\", key)?; s.end() } Request::Set { ref key, ref val } =\u003e { let mut s = serializer.serialize_struct_variant(\"Request\", 1, \"Set\", 2)?; s.serialize_field(\"key\", key)?; s.serialize_field(\"val\", val)?; s.end() } Request::Rm { ref key } =\u003e { let mut s = s.serialize_struct_variant(\"Request\", 2, \"Rm\", 1)?; s.serialize_field(\"key\", key)?; s.end(s) } } } } Instead of manually running serialize_field on each field of our enum, the macro will automatically generate the necessary code for us. This makes it easier to use in most cases.\nTo understand the flow, let’s break down what the serialize method does. It knows how to instruct Serializer to serialize the Request struct. Then, for each field in the enum, it calls serialize_field by using Serializer that is passed to serialize method.\nIf you want to use an existing serializer, like a JSON serializer, you can pass that serializer into the serialize method. The serializer will then handle the serialization process for you, converting your Rust data types into a JSON compatible format.\nHowever, in our case, we want to serialize the Request data type into our custom data format, which is not compatible with JSON or any other standard data formats. This means we need to implement our own custom serialization logic to handle this specific format - at least as scope of this blog post :).\nTo write our own Serializer, we need to implement serde::ser::Serializer trait. If you check the trait, it includes lots of required methods. But of course, not all of these methods need to be implemented in every case. Most of the methods are related to serializing specific types, like structs or i32.\nIn our case, we need to serialize a struct type. Based on the code generated by Serialize macro, we call serialize_struct_variant method. Therefore, we’ll definitely need to implement this method.\nAlso, we need to specify some required associated types of Serializer trait: Ok, Error and SerializeStructVariant in the Serializer trait.\ntype Ok corresponds to the output type that we generate after serialization. In our case, we can use () for Ok value since we are going to store the the serialization result in-memory and then write it to io::Write.\ntype Error corresponds to the error type that we may face during serialization. For the error type, we can define a custom Error type by following conventions here.\ntype SerializeStructVariant corresponds to the type returned from the serialize_struct_variant method. We can set SerializeStructVariant to Self, meaning our Serializer will be returned as the result of the serialize_struct_variant method. This allows us to use the serialization methods that we define within our custom Serializer.\nHere’s a simplified version of what our Serializer implementation will look like (omitting other methods that we don’t need to implement):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 impl\u003c'a\u003e ser::Serializer for \u0026'a mut KvRequestSerializer { type Ok = (); type Error = Error; type SerializeStructVariant = Self; fn serialize_struct_variant( self, _name: \u0026'static str, _variant_index: u32, variant: \u0026'static str, _len: usize, ) -\u003e std::result::Result\u003cSelf::SerializeStructVariant, Self::Error\u003e { let req_type = match variant { \"Set\" =\u003e Ok(\"set\"), \"Get\" =\u003e Ok(\"get\"), \"Rm\" =\u003e Ok(\"rm\"), _ =\u003e Err(Error::InvalidData(String::from(\"invalid request provided\"))), }?; self.output += \"\\r\"; self.output += \":\"; self.output += req_type; Ok(self) } // and other required methods and types... } impl\u003c'a\u003e ser::SerializeStructVariant for \u0026'a mut KvRequestSerializer { type Ok = (); type Error = Error; fn serialize_field\u003cT\u003e( \u0026mut self, _key: \u0026'static str, value: \u0026T, ) -\u003e std::result::Result\u003c(), Self::Error\u003e where T: ?Sized + Serialize, { value.serialize(\u0026mut **self)?; Ok(()) } fn end(self) -\u003e std::result::Result\u003cSelf::Ok, Self::Error\u003e { self.output += \":\"; Ok(()) } } So, for example in order to serialize Request::Get {key: \"abc\"}, based on the serialize method (which is generated by Serialize macro)\n1 2 3 4 5 6 7 8 9 10 11 // serialize_struct_variant returns Result // which means succesfull results yield Self::SerializeStructVariant. // In our case, we defined `type SerializeStructVariant` as Self again. // So, the result of `serialize_struct_variant` method will be `KvRequestSerializer`. // // In the following code, `s` is type of KvRequestSerializer // which implements SerializeStructVariant trait. So that we can serialize the structs. let mut s = serializer.serialize_struct_variant(\"Request\", 0, \"Get\", 1)?; // now, s points to KvRequestSerializer and we already implement SerializeStructVariant trait. s.serialize_field(\"key\", key)?; s.end() This flow will be resulted through following process:\nKvRequestSerializer’s serialize_struct_variant method. Here, we have information about how our Rust data type look like. KvRequestSerializer’s serialize_field method in SerializeStructVariant trait implementation. Here, we know each key of the Request::Get enum and its values KvRequestSerializer’s serialize_str. Then we pass the value of key field to serialize_str. So that we can form our desired data format Lastly we call end method from SerializeStructVariant During the process, we store the result of each operation in the output field of our Serializer. At the end, we can pass this output to our desired output location.\nNow, we implemented our serializer. Let’s write a simple test to verify the result. Before jumping into test cases, let’s define a function that eases usage of our serializer.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 pub fn serialize\u003cT: ser::Serialize\u003e(request: \u0026T) -\u003e String { let mut serializer = KvRequestSerializer { output: String::new(), }; request.serialize(\u0026mut serializer).expect(\"failed to serialize\"); serializer.output } #[test] fn test_serialization_request_struct() { use crate::request::Request; let get_request = Request::Get { key: \"get_key_testing\".to_owned(), }; let expected_get = \"\\r:get get_key_testing:\"; assert_eq!(serialize(\u0026get_request), expected_get); } Now that our serializer works as expected, let’s move on to deserializing our custom data format into the Request type by implementing our own deserializer.\nDeserialization Writing a custom deserializer can be more complicated than writing a serializer. I found myself confused quite often while working on the implementation at first. However, I’ll try to simplify the explanation as much as possible.\nIn serde, deserialization is a two-phase process that involves both a Deserializer and a Visitor. Let’s start with the Deserializer.\nDeserializer is responsible for interpreting the input, which is a data format in form of string, byte, binary etc., and matching this input data format to serde data model, such as integer, sequence and so on. Here, the serde data model refers to the data types defined within serde, which correspond closely to Rust’s type system. For example, bool in serde corresponds to the boolean type in Rust. The serde documentation provides a clear explanation of the data model, including an example using OsString, which is highly recommended if you’re not already familiar with serde’s data model. Please refer to the docs https://serde.rs/data-model.html.\nOnce the Deserializer matches input data to the appropriate serde data model, a Visitor is then used to analyze this generic data and convert it into the specific data type we want to achieve.\nAlthough this process may sound complicated, let’s break it down using a concrete example based on our case. Suppose we have a string like get abc:. Our deserialize method will call deserialize_str on our custom deserializer. This flow is similar to how the Serializer calls serialize_struct_variant, knowing that the data type is a struct. In our case, we know that our data format is a string that contains a single request. Thus, we will call deserialize_str. As opposed to serialize method, now we do not need to use macro to autogenerate deserialize method for Request type. As we already know that the input data format will be a string, we will implement deserialize method in a way that it will call deserialize_str method of our custom deserializer.\nWhen the deserializer’s deserialize_str method is called, it will, in turn, call the visit_str method on a visitor that we provide. This means we need to implement our own Visitor to handle string representation of our custom data format. Finally, within the visit_str method of our Visitor, we will parse the string and create the corresponding Request enum type based on the input.\nLet’s try to implement this deserialization process. As we did with the Serializer, we’ll start with the deserialize method for our data type - Request enum - which will instruct our custom deserializer.\n1 2 3 4 5 6 7 8 impl\u003c'de\u003e de::Deserialize\u003c'de\u003e for Request { fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e where D: de::Deserializer\u003c'de\u003e, { deserializer.deserialize_str(RequestVisitor) } } If we look at the deserialize method, you’ll notice that we pass our deserializer to this method (similar to how we did it with the serialize method). Since we know our custom data format is a string, we’ll directly call deserialize_str. This is actually suitable for our simple data format. However, we also need to pass a RequestVisitor as an argument to deserialize_str. This requires us to create a visitor that implements the de::Visitor trait. The RequestVisitor will process the string input and try to generate the appropriate Request enum.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 pub struct RequestVisitor; impl\u003c'de\u003e de::Visitor\u003c'de\u003e for RequestVisitor { type Value = Request; fn expecting(\u0026self, formatter: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result { formatter.write_str(\"a command in the format ': '\") } fn visit_str\u003cE\u003e(self, cmd_str: \u0026str) -\u003e std::result::Result\u003cSelf::Value, E\u003e where E: de::Error, { let inputs = cmd_str.split_whitespace().collect::\u003cVec\u003c\u0026str\u003e\u003e(); let len = inputs.len(); if len != 2 \u0026\u0026 len != 3 { return Err(de::Error::custom( \"invalid command request provided, valid commands are 'get', 'set' and 'rm'\", )); } let cmd_name = inputs[0]; let get_key = |key: \u0026str| -\u003e String { let trimmed = key.trim(); if trimmed.ends_with(\":\") { return trimmed .get(0..trimmed.len() - 1) .unwrap_or(trimmed) .to_owned(); } return trimmed.to_owned(); }; let key = inputs[1]; match cmd_name { \"get\" =\u003e Ok(Request::Get { key: get_key(key) }), \"rm\" =\u003e Ok(Request::Rm { key: get_key(key) }), \"set\" =\u003e { let val = inputs[2].trim(); Ok(Request::Set { key: key.to_owned(), val: get_key(val), }) } _ =\u003e Err(de::Error::custom( \"invalid command is provided, valid commands are 'get', 'set' and 'rm'\", )), } } } The Visitor trait has only one required method: expecting which will be used in error messages. While other methods like visit_str have default implementations, we need to override and implement the methods necessary for our use case. In this case, since we are working with string values, we’ll implement visit_str, which will handle parsing the given string.\nFor our example, visit_str will expect strings like get abc:, set key value:, or rm key:. The visit_str method will attempt to convert these strings into the corresponding Request enum variants.\nFinally we can implement our deserializer which will simply call the visitor’s visit_str method, as follows:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 pub struct Deserializer\u003c'de\u003e { input: \u0026'de str, } impl\u003c'de, 'a\u003e de::Deserializer\u003c'de\u003e for \u0026'a mut Deserializer\u003c'de\u003e { type Error = Error; fn deserialize_str\u003cV\u003e(self, visitor: V) -\u003e std::result::Result\u003cV::Value, Self::Error\u003e where V: de::Visitor\u003c'de\u003e, { visitor.visit_str::\u003cSelf::Error\u003e(\u0026self.input) } // Rest of the deserialize_* methods ... // // As Serializer, i do not list them all here as there is a deserialize_* // method for almost all type. // // For more detail about it, please refer to the: // https://docs.rs/serde/1.0.208/serde/trait.Deserializer.html# } This approach keeps the deserialization process straightforward and clean. Now, let’s write a simple test scenario to verify our implementation.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 fn deserialize\u003c'a, T: de::Deserialize\u003c'a\u003e\u003e(input: \u0026'a str) -\u003e Result\u003cT\u003e { let mut deserializer = Deserializer::from_str(input); let t = T::deserialize(\u0026mut deserializer)?; Ok(t) } #[test] fn test_deserialize_set() { let data = r\"set burak 123:\"; let expected = Request::Set { key: \"burak\".to_string(), val: \"123\".to_string(), }; let result: Request = deserialize(data).expect(\"failed to deserialize\"); } I hope this post helps you get started with your own serde implementations. Since I am also a beginner in Rust, I encourage you to always refer to the official serde documentation as the primary source of truth.\nAlso, the source code is available on GitHub: https://github.com/buraksekili/kvs_protocol/\nIf you notice any mistakes or have feedback, feel free to reach out to me on Twitter, LinkedIn, or GitHub.\nReferences https://serde.rs/ https://owengage.com/writing/2021-08-14-exploring-serdes-data-model-with-a-toy-deserializer/ ",
  "wordCount" : "3264",
  "inLanguage": "en",
  "datePublished": "2024-08-23T00:00:00Z",
  "dateModified": "2024-08-23T16:30:50+03:00",
  "author":{
    "@type": "Person",
    "name": "Burak Sekili"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://buraksekili.github.io/articles/rust-serde/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Burak Sekili",
    "logo": {
      "@type": "ImageObject",
      "url": "https://buraksekili.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://buraksekili.github.io/" accesskey="h" title="Burak Sekili (Alt + H)">Burak Sekili</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://buraksekili.github.io/archives/" title="Articles">
                    <span>Articles</span>
                </a>
            </li>
            <li>
                <a href="https://buraksekili.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://buraksekili.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://buraksekili.github.io/articles/">Articles</a></div>
    <h1 class="post-title">
      Working with Custom Data Format in Rust using serde
    </h1>
    <div class="post-description">
      How to serialize and deserialize a custom custom data format in Rust using serde
    </div>
    <div class="post-meta"><span title='2024-08-23 00:00:00 +0000 UTC'>August 23, 2024</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Burak Sekili
</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#working-with-custom-data-format-in-rust-using-serde" aria-label="Working with Custom Data Format in Rust using serde">Working with Custom Data Format in Rust using serde</a></li>
                <li>
                    <a href="#concepts" aria-label="Concepts">Concepts</a><ul>
                        
                <li>
                    <a href="#data-format" aria-label="Data Format">Data Format</a></li>
                <li>
                    <a href="#data-type" aria-label="Data Type">Data Type</a></li>
                <li>
                    <a href="#serialization-and-deserialization" aria-label="Serialization and Deserialization">Serialization and Deserialization</a></li></ul>
                </li>
                <li>
                    <a href="#serialization" aria-label="Serialization">Serialization</a></li>
                <li>
                    <a href="#deserialization" aria-label="Deserialization">Deserialization</a></li>
                <li>
                    <a href="#references" aria-label="References">References</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="working-with-custom-data-format-in-rust-using-serde">Working with Custom Data Format in Rust using serde<a hidden class="anchor" aria-hidden="true" href="#working-with-custom-data-format-in-rust-using-serde">#</a></h2>
<p>If you need to perform serialization or deserialization in Rust, you’ve most likely used the <em>serde</em> before.
I’m currently learning Rust, and I found myself needing similar thing.</p>
<p>To get familiar with the Rust ecosystem, I decided to develop a simple key-value store.
Initially, the engine for this key-value store was designed to work with JSON objects, as JSON is a widely-used format that’s straightforward to use with web clients.
Also, as most of the languages and platforms already support JSON, it is a good choice to start with.</p>
<p>What I wanted to achieve was that users send JSON objects to indicate their request,
such as &ldquo;give me the value of key <key>&rdquo;, which can be represented as <code>{ &quot;key&quot;: &quot;some_key&quot; }</code> in JSON.
The response is also formatted as a JSON object, like <code>{&quot;value&quot;: &quot;value_of_the_key&quot;}</code>. The concept and requirements of this server are quite simple and clear.</p>
<p>I generally use Go for my projects, where the JSON serialization/deserialization process is straightforward.
You can manage it with some tags on your struct, and the rest is handled by Go itself.
In Rust, achieving the same thing is also straightforward with <em>serde</em>.
You only need to add a few macros, and serde will automatically implement serialization and deserialization methods for you.
As JSON is one of the most popular data formats, you can set this up with just a few lines of code. I am not going to give details about how to achieve this as
<a href="https://serde.rs/">serde documentation</a> has handful examples regarding this.</p>
<p>After checking similar projects, I realized that most of the engines do not use these widely adopted data formats in place with their storage engine.
Of course, the reasons of this may vary but the fundamental concerns are more or less the same: performance and simplicity. In my case, users only <code>get</code>, <code>set</code> or <code>rm</code>
the key. So, using JSON is a bit overkill here.
I totally agree that it is quite straightforward to implement and get start with JSON but what happens if I want to introduce a simple - and to be honest useless and dumbest -
data format to interact with my key-value storage engine? Considering that my learning purpose of Rust, the idea looks okay to me.</p>
<p>Then, I started to focus on how to work with custom data format with <em>serde</em>? So that I can serialize Rust data types to my data format and deserialize some byte sequence such
as strings back to Rust types?</p>
<h2 id="concepts">Concepts<a hidden class="anchor" aria-hidden="true" href="#concepts">#</a></h2>
<p>Before jumping into implementation details, it&rsquo;d be better to get familiar with some core concepts that we are going to be using.</p>
<h3 id="data-format">Data Format<a hidden class="anchor" aria-hidden="true" href="#data-format">#</a></h3>
<p>First things first, let’s try to understand what the data format is. Simply put, a data format defines how the data is stored and structured.
For example, well-known data formats such as JSON, CSV, and TOML can store the same data but in different ways.</p>
<p>You probably use these formats on a daily basis as they are widely adopted and used. Almost every language support these data formats more or less.
Although these formats use different syntax while representing the data, the underlying data they represent is the same.</p>
<p>In my case, I wanted to introduce a simple custom data format, which looks like this:</p>
<pre tabindex="0"><code>\r:&lt;cmd_name&gt; &lt;key&gt; &lt;optional_value&gt;:
</code></pre><p>This format allows me to store a sequence of commands - essentially the requests that users send to the key-value engine, such as fetching a key - in a log file.
This format is of course not complicated and maybe even not quite helpful compared to JSON but it is of course cleaner and easier for me to work with.
For instance, using this format makes it easy for my parser to determine where a command request
starts in the file, as each command is prefixed with <code>\r:</code> and ends with a colon <code>:</code>.</p>
<p>This data format of course is NOT a JSON (or YAML, CSV and whatever) which means I cannot use existing deserializer of already knowns data formats.
This means I need to implement my own basic serializer and deserializer to convert Rust data structures,
such as enum or struct, into this custom format and vice versa.</p>
<blockquote>
<p>For simple use cases like mine, you do not even need to write a full <code>Serializer</code> and <code>Deserializer</code> using serde.
You can implement a custom deserialize method and a visitor to handle most tasks. My primary goal in creating these custom serializers and deserializers is to learn and understand the process better.</p>
</blockquote>
<h3 id="data-type">Data Type<a hidden class="anchor" aria-hidden="true" href="#data-type">#</a></h3>
<p>The data types refer to the way data is stored in memory and classified in the language that we use.
In Rust and in many other languages, data types can be simple types such as integers, floating number, booleans and
composite ones like structs, enums, and classes.</p>
<p>On the other hand, data format is how this data type is stored and structured in the storage.</p>
<p>For example, the following <code>Get</code> struct in Rust corresponds to the data type:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Get</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">key</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>where, storing this data type as a JSON string as <code>{&quot;key&quot;: &quot;some_key&quot;}</code> is the data format.</p>
<h3 id="serialization-and-deserialization">Serialization and Deserialization<a hidden class="anchor" aria-hidden="true" href="#serialization-and-deserialization">#</a></h3>
<p>With that being said, serialization is the process of converting or transforming these data types into a specific data format.
For example, if you use a JSON serializer, it will convert your Rust data types into a JSON compatible string representation.</p>
<p>The deserialization is kind of the reverse process of the serialization where it takes your input (like as a string, byte sequence or in binary)
and converts this input back into the data types, which might be struct or vector etc.</p>
<h2 id="serialization">Serialization<a hidden class="anchor" aria-hidden="true" href="#serialization">#</a></h2>
<p>As clearly mentioned in <a href="https://serde.rs/data-format.html">serde documentation</a>, serde is NOT a parsing library. So, i am not going to dive into
how to parse the stream.</p>
<p>In our case, the request that users send is represented as enum type, as follows:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">Request</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Get</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">key</span>: <span class="nb">String</span> <span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Set</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">key</span>: <span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">val</span>: <span class="nb">String</span> <span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Rm</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">key</span>: <span class="nb">String</span> <span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>First start with serializing this data type into our custom data format:</p>
<pre tabindex="0"><code>\r:&lt;cmd_name&gt; &lt;key&gt; &lt;optional_value&gt;:
</code></pre><p>In order to serialize our enum, we need to implement <a href="https://docs.rs/serde/1.0.208/serde/ser/trait.Serialize.html">Serialize</a> trait for our <code>Request</code>
type. This trait only has one required method called <code>serialize</code>. For most of the time, you do not need to implement the trait from scratch.
There is a helper procedural macro called <code>serde_derive</code> to implement the trait for you. So, let&rsquo;s add this macro to our type.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">serde</span>::<span class="n">Serialize</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[derive(Serialize)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">Request</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Get</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">key</span>: <span class="nb">String</span> <span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Set</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">key</span>: <span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">val</span>: <span class="nb">String</span> <span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Rm</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">key</span>: <span class="nb">String</span> <span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Eventually, this macro generates the following code (which shows the generated code in simplified manner) for <code>Request</code> struct.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="c1">// for more, please check https://docs.rs/serde/1.0.208/serde/ser/trait.Serialize.html
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Serialize</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Request</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">serialize</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">serializer</span>: <span class="nc">S</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">S</span>::<span class="nb">Ok</span><span class="p">,</span><span class="w"> </span><span class="n">S</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">where</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">S</span>: <span class="nc">Serializer</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="o">*</span><span class="bp">self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">Request</span>::<span class="n">Get</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">serializer</span><span class="p">.</span><span class="n">serialize_struct_variant</span><span class="p">(</span><span class="s">&#34;Request&#34;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Get&#34;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">s</span><span class="p">.</span><span class="n">serialize_field</span><span class="p">(</span><span class="s">&#34;key&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">Request</span>::<span class="n">Set</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">serializer</span><span class="p">.</span><span class="n">serialize_struct_variant</span><span class="p">(</span><span class="s">&#34;Request&#34;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Set&#34;</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">s</span><span class="p">.</span><span class="n">serialize_field</span><span class="p">(</span><span class="s">&#34;key&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">s</span><span class="p">.</span><span class="n">serialize_field</span><span class="p">(</span><span class="s">&#34;val&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">Request</span>::<span class="n">Rm</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">serialize_struct_variant</span><span class="p">(</span><span class="s">&#34;Request&#34;</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Rm&#34;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">s</span><span class="p">.</span><span class="n">serialize_field</span><span class="p">(</span><span class="s">&#34;key&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Instead of manually running <code>serialize_field</code> on each field of our enum, the macro will automatically generate the necessary code for us.
This makes it easier to use in most cases.</p>
<p>To understand the flow, let’s break down what the <code>serialize</code> method does. It knows how to instruct <code>Serializer</code> to serialize the <code>Request</code> struct.
Then, for each field in the enum, it calls <code>serialize_field</code> by using Serializer that is passed to <code>serialize</code> method.</p>
<p>If you want to use an existing serializer, like a JSON serializer, you can pass that serializer into the serialize method.
The serializer will then handle the serialization process for you, converting your Rust data types into a JSON compatible format.</p>
<p>However, in our case, we want to serialize the Request data type into our custom data format, which is not compatible with JSON or
any other standard data formats. This means we need to implement our own custom serialization logic to handle this specific format - at least as
scope of this blog post :).</p>
<p>To write our own Serializer, we need to implement <a href="https://docs.rs/serde/1.0.208/serde/trait.Serializer.html"><code>serde::ser::Serializer</code> trait</a>.
If you check the trait, it includes lots of required methods. But of course, not all of these methods need to be implemented in every case.
Most of the methods are related to serializing specific types, like structs or i32.</p>
<p>In our case, we need to serialize a struct type. Based on the code generated by Serialize macro, we call <code>serialize_struct_variant</code> method.
Therefore, we&rsquo;ll definitely need to implement this method.</p>
<p>Also, we need to specify some required associated types of Serializer trait: <code>Ok</code>, <code>Error</code> and <code>SerializeStructVariant</code> in the Serializer trait.</p>
<ul>
<li><code>type Ok</code> corresponds to the output type that we generate after serialization.</li>
</ul>
<p>In our case, we can use <code>()</code> for Ok value since we are going to store the the serialization result in-memory and then write it to <code>io::Write</code>.</p>
<ul>
<li>
<p><code>type Error</code> corresponds to the error type that we may face during serialization.
For the error type, we can define a custom <code>Error</code> type by following conventions <a href="">here</a>.</p>
</li>
<li>
<p><code>type SerializeStructVariant</code> corresponds to the type returned from the <code>serialize_struct_variant</code> method.
We can set <code>SerializeStructVariant</code> to <code>Self</code>, meaning our <code>Serializer</code> will be returned as the result of the <code>serialize_struct_variant</code> method.
This allows us to use the serialization methods that we define within our custom <code>Serializer</code>.</p>
</li>
</ul>
<p>Here’s a simplified version of what our Serializer implementation will look like (omitting other methods that we don&rsquo;t need to implement):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ser</span>::<span class="n">Serializer</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">KvRequestSerializer</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">type</span> <span class="nb">Ok</span> <span class="o">=</span><span class="w"> </span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">type</span> <span class="nc">Error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Error</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">type</span> <span class="nc">SerializeStructVariant</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">serialize_struct_variant</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">self</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">_name</span>: <span class="kp">&amp;</span><span class="nb">&#39;static</span> <span class="kt">str</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">_variant_index</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">variant</span>: <span class="kp">&amp;</span><span class="nb">&#39;static</span> <span class="kt">str</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">_len</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">std</span>::<span class="n">result</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">SerializeStructVariant</span><span class="p">,</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">req_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">variant</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="s">&#34;Set&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="s">&#34;set&#34;</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="s">&#34;Get&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="s">&#34;get&#34;</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="s">&#34;Rm&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="s">&#34;rm&#34;</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">Error</span>::<span class="n">InvalidData</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;invalid request provided&#34;</span><span class="p">))),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">output</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&#34;</span><span class="se">\r</span><span class="s">&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">output</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&#34;:&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">output</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">req_type</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// and other required methods and types...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ser</span>::<span class="n">SerializeStructVariant</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">KvRequestSerializer</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">type</span> <span class="nb">Ok</span> <span class="o">=</span><span class="w"> </span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">type</span> <span class="nc">Error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Error</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">serialize_field</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">_key</span>: <span class="kp">&amp;</span><span class="nb">&#39;static</span> <span class="kt">str</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">value</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">std</span>::<span class="n">result</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">where</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Serialize</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">value</span><span class="p">.</span><span class="n">serialize</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="o">**</span><span class="bp">self</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">end</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">std</span>::<span class="n">result</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="nb">Ok</span><span class="p">,</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">output</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&#34;:&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>So, for example in order to serialize <code>Request::Get {key: &quot;abc&quot;}</code>, based on the <code>serialize</code> method (which is generated by <code>Serialize</code> macro)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="c1">// serialize_struct_variant returns Result&lt;Self::SerializeStructVariant, Self::Error&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1">// which means succesfull results yield Self::SerializeStructVariant.
</span></span></span><span class="line"><span class="cl"><span class="c1">// In our case, we defined `type SerializeStructVariant` as Self again.
</span></span></span><span class="line"><span class="cl"><span class="c1">// So, the result of `serialize_struct_variant` method will be `KvRequestSerializer`.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// In the following code, `s` is type of KvRequestSerializer
</span></span></span><span class="line"><span class="cl"><span class="c1">// which implements SerializeStructVariant trait. So that we can serialize the structs.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">serializer</span><span class="p">.</span><span class="n">serialize_struct_variant</span><span class="p">(</span><span class="s">&#34;Request&#34;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Get&#34;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// now, s points to KvRequestSerializer and we already implement SerializeStructVariant trait.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">s</span><span class="p">.</span><span class="n">serialize_field</span><span class="p">(</span><span class="s">&#34;key&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">()</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>This flow will be resulted through following process:</p>
<ol>
<li><code>KvRequestSerializer</code>&rsquo;s <code>serialize_struct_variant</code> method.
Here, we have information about how our Rust data type look like.</li>
<li><code>KvRequestSerializer</code>&rsquo;s <code>serialize_field</code> method in <code>SerializeStructVariant</code> trait implementation.
Here, we know each key of the Request::Get enum and its values</li>
<li><code>KvRequestSerializer</code>&rsquo;s <code>serialize_str</code>.
Then we pass the value of <code>key</code> field to <code>serialize_str</code>. So that we can form our desired data format</li>
<li>Lastly we call <code>end</code> method from <code>SerializeStructVariant</code></li>
</ol>
<p>During the process, we store the result of each operation in the <code>output</code> field of our Serializer.
At the end, we can pass this <code>output</code> to our desired output location.</p>
<p>Now, we implemented our serializer. Let&rsquo;s write a simple test to verify the result. Before jumping into test cases, let&rsquo;s define
a function that eases usage of our serializer.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">serialize</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">ser</span>::<span class="n">Serialize</span><span class="o">&gt;</span><span class="p">(</span><span class="n">request</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">serializer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">KvRequestSerializer</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">output</span>: <span class="nb">String</span>::<span class="n">new</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">request</span><span class="p">.</span><span class="n">serialize</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">serializer</span><span class="p">).</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;failed to serialize&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">serializer</span><span class="p">.</span><span class="n">output</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[test]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">test_serialization_request_struct</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="k">crate</span>::<span class="n">request</span>::<span class="n">Request</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">get_request</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Request</span>::<span class="n">Get</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">key</span>: <span class="s">&#34;get_key_testing&#34;</span><span class="p">.</span><span class="n">to_owned</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">expected_get</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;</span><span class="se">\r</span><span class="s">:get get_key_testing:&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">serialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">get_request</span><span class="p">),</span><span class="w"> </span><span class="n">expected_get</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Now that our serializer works as expected, let&rsquo;s move on to deserializing our custom data format into the <code>Request</code> type by implementing our own deserializer.</p>
<h2 id="deserialization">Deserialization<a hidden class="anchor" aria-hidden="true" href="#deserialization">#</a></h2>
<p>Writing a custom deserializer can be more complicated than writing a serializer. I found myself confused quite often while working on the implementation at first. However, I&rsquo;ll try to simplify the explanation as much as possible.</p>
<p>In <em>serde</em>, deserialization is a two-phase process that involves both a <code>Deserializer</code> and a <code>Visitor</code>. Let&rsquo;s start with the <code>Deserializer</code>.</p>
<p>Deserializer is responsible for interpreting the input, which is a data format in form of string, byte, binary etc., and matching
this input data format to serde data model, such as integer, sequence and so on.
Here, the <em>serde</em> data model refers to the data types defined within <em>serde</em>, which correspond closely to Rust&rsquo;s type system.
For example, <code>bool</code> in <em>serde</em> corresponds to the <code>boolean</code> type in Rust.
The <em>serde</em> documentation provides a clear explanation of the data model, including an example using <code>OsString</code>, which is highly recommended
if you&rsquo;re not already familiar with <em>serde</em>&rsquo;s data model. Please refer to the docs <a href="https://serde.rs/data-model.html">https://serde.rs/data-model.html</a>.</p>
<p>Once the <code>Deserializer</code> matches input data to the appropriate <em>serde</em> data model,
a <em>Visitor</em> is then used to analyze this generic data and convert it into the specific data type we want to achieve.</p>
<p>Although this process may sound complicated, let&rsquo;s break it down using a concrete example based on our case.
Suppose we have a string like <code>get abc:</code>. Our <code>deserialize</code> method will call <code>deserialize_str</code> on our custom deserializer.
This flow is similar to how the <code>Serializer</code> calls <code>serialize_struct_variant</code>, knowing that the data type is a struct.
In our case, we know that our data format is a string that contains a single request. Thus, we will call <code>deserialize_str</code>.
As opposed to <code>serialize</code> method, now we do not need to use macro to autogenerate <code>deserialize</code> method for <code>Request</code> type.
As we already know that the input data format will be a string, we will implement <code>deserialize</code> method in a way that it will
call <code>deserialize_str</code> method of our custom deserializer.</p>
<p>When the deserializer&rsquo;s <code>deserialize_str</code> method is called, it will, in turn, call the <code>visit_str</code> method on a visitor that we provide.
This means we need to implement our own Visitor to handle string representation of our custom data format.
Finally, within the <code>visit_str</code> method of our Visitor, we will parse the string and create the corresponding <code>Request</code> enum type based on the input.</p>
<p>Let&rsquo;s try to implement this deserialization process. As we did with the Serializer, we&rsquo;ll start with the deserialize method for
our data type - <code>Request</code> enum - which will instruct our custom deserializer.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;de</span><span class="o">&gt;</span><span class="w"> </span><span class="n">de</span>::<span class="n">Deserialize</span><span class="o">&lt;</span><span class="na">&#39;de</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Request</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">deserialize</span><span class="o">&lt;</span><span class="n">D</span><span class="o">&gt;</span><span class="p">(</span><span class="n">deserializer</span>: <span class="nc">D</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="bp">Self</span><span class="p">,</span><span class="w"> </span><span class="n">D</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">where</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">D</span>: <span class="nc">de</span>::<span class="n">Deserializer</span><span class="o">&lt;</span><span class="na">&#39;de</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">deserializer</span><span class="p">.</span><span class="n">deserialize_str</span><span class="p">(</span><span class="n">RequestVisitor</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>If we look at the <code>deserialize</code> method, you&rsquo;ll notice that we pass our deserializer to this method
(similar to how we did it with the <code>serialize</code> method).
Since we know our custom data format is a string, we&rsquo;ll directly call <code>deserialize_str</code>.
This is actually suitable for our simple data format.
However, we also need to pass a <code>RequestVisitor</code> as an argument to <code>deserialize_str</code>.
This requires us to create a visitor that implements the <a href="https://docs.rs/serde/1.0.208/serde/de/trait.Visitor.html"><code>de::Visitor</code> trait</a>. The <code>RequestVisitor</code> will process the string input and try to generate the appropriate <code>Request</code> enum.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">RequestVisitor</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;de</span><span class="o">&gt;</span><span class="w"> </span><span class="n">de</span>::<span class="n">Visitor</span><span class="o">&lt;</span><span class="na">&#39;de</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">RequestVisitor</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">type</span> <span class="nc">Value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Request</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">expecting</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">formatter</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span>::<span class="n">Formatter</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">std</span>::<span class="n">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">formatter</span><span class="p">.</span><span class="n">write_str</span><span class="p">(</span><span class="s">&#34;a command in the format &#39;:&lt;cmd&gt; &lt;required_key&gt; &lt;optional_value&gt;&#39;&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">visit_str</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">cmd_str</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">std</span>::<span class="n">result</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Value</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">where</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">E</span>: <span class="nc">de</span>::<span class="n">Error</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">inputs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cmd_str</span><span class="p">.</span><span class="n">split_whitespace</span><span class="p">().</span><span class="n">collect</span>::<span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="kt">str</span><span class="o">&gt;&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inputs</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">de</span>::<span class="n">Error</span>::<span class="n">custom</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="s">&#34;invalid command request provided, valid commands are &#39;get&#39;, &#39;set&#39; and &#39;rm&#39;&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">cmd_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">get_key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">key</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="o">|</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">trimmed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">key</span><span class="p">.</span><span class="n">trim</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">trimmed</span><span class="p">.</span><span class="n">ends_with</span><span class="p">(</span><span class="s">&#34;:&#34;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">trimmed</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">trimmed</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">.</span><span class="n">unwrap_or</span><span class="p">(</span><span class="n">trimmed</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">.</span><span class="n">to_owned</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">trimmed</span><span class="p">.</span><span class="n">to_owned</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">cmd_name</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="s">&#34;get&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">Request</span>::<span class="n">Get</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">key</span>: <span class="nc">get_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">}),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="s">&#34;rm&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">Request</span>::<span class="n">Rm</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">key</span>: <span class="nc">get_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">}),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="s">&#34;set&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inputs</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">trim</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="nb">Ok</span><span class="p">(</span><span class="n">Request</span>::<span class="n">Set</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">key</span>: <span class="nc">key</span><span class="p">.</span><span class="n">to_owned</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">val</span>: <span class="nc">get_key</span><span class="p">(</span><span class="n">val</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">})</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">de</span>::<span class="n">Error</span>::<span class="n">custom</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="s">&#34;invalid command is provided, valid commands are &#39;get&#39;, &#39;set&#39; and &#39;rm&#39;&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">)),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>The <code>Visitor</code> trait has only one required method: <code>expecting</code> which will be used in error messages.
While other methods like <code>visit_str</code> have default implementations, we need to override and implement the methods necessary for our use case.
In this case, since we are working with string values, we&rsquo;ll implement <code>visit_str</code>, which will handle parsing the given string.</p>
<p>For our example, <code>visit_str</code> will expect strings like <code>get abc:</code>, <code>set key value:</code>, or <code>rm key:</code>.
The <code>visit_str</code> method will attempt to convert these strings into the corresponding <code>Request</code> enum variants.</p>
<p>Finally we can implement our deserializer which will simply call the visitor&rsquo;s <code>visit_str</code> method, as follows:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Deserializer</span><span class="o">&lt;</span><span class="na">&#39;de</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">input</span>: <span class="kp">&amp;</span><span class="na">&#39;de</span> <span class="kt">str</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;de</span><span class="p">,</span><span class="w"> </span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">de</span>::<span class="n">Deserializer</span><span class="o">&lt;</span><span class="na">&#39;de</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">Deserializer</span><span class="o">&lt;</span><span class="na">&#39;de</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">type</span> <span class="nc">Error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Error</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">deserialize_str</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">visitor</span>: <span class="nc">V</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">std</span>::<span class="n">result</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="n">V</span>::<span class="n">Value</span><span class="p">,</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">where</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">V</span>: <span class="nc">de</span>::<span class="n">Visitor</span><span class="o">&lt;</span><span class="na">&#39;de</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">visitor</span><span class="p">.</span><span class="n">visit_str</span>::<span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">input</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Rest of the deserialize_* methods ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// As Serializer, i do not list them all here as there is a deserialize_*
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// method for almost all type.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// For more detail about it, please refer to the:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">//      https://docs.rs/serde/1.0.208/serde/trait.Deserializer.html#
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>This approach keeps the deserialization process straightforward and clean. Now, let&rsquo;s write a simple test scenario to verify our implementation.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">deserialize</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="nc">de</span>::<span class="n">Deserialize</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">input</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span> <span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">deserializer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Deserializer</span>::<span class="n">from_str</span><span class="p">(</span><span class="n">input</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span>::<span class="n">deserialize</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">deserializer</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[test]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">test_deserialize_set</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sa">r</span><span class="s">&#34;set burak 123:&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">expected</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Request</span>::<span class="n">Set</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">key</span>: <span class="s">&#34;burak&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">val</span>: <span class="s">&#34;123&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span>: <span class="nc">Request</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">deserialize</span><span class="p">(</span><span class="n">data</span><span class="p">).</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;failed to deserialize&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><hr>
<p>I hope this post helps you get started with your own <em>serde</em> implementations.
Since I am also a beginner in Rust, I encourage you to always refer to the official <em>serde</em> documentation as the
primary source of truth.</p>
<p>Also, the source code is available on GitHub: <a href="https://github.com/buraksekili/kvs_protocol/">https://github.com/buraksekili/kvs_protocol/</a></p>
<p>If you notice any mistakes or have feedback, feel free to reach out to me on <a href="https://x.com/buraksekili">Twitter</a>, <a href="https://www.linkedin.com/in/sekili/">LinkedIn</a>, or GitHub.</p>
<h2 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h2>
<ul>
<li><a href="https://serde.rs/">https://serde.rs/</a></li>
<li><a href="https://owengage.com/writing/2021-08-14-exploring-serdes-data-model-with-a-toy-deserializer/">https://owengage.com/writing/2021-08-14-exploring-serdes-data-model-with-a-toy-deserializer/</a></li>
</ul>


  </div>

  <footer class="post-footer">
    <div class="social-icons"><a class="edit-post-span"
    href="https://github.com/buraksekili/buraksekili.github.io/blob/main/content/articles/rust-serde.md"
    rel="noopener noreferrer" target="_blank">Edit this page on <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
        stroke-linecap="round" stroke-linejoin="round">
        <path
            d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22">
        </path>
    </svg>
</a></div>

    <ul class="post-tags">
      <li><a href="https://buraksekili.github.io/tags/rust/">Rust</a></li>
      <li><a href="https://buraksekili.github.io/tags/serde/">Serde</a></li>
    </ul>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Working with Custom Data Format in Rust using serde on twitter"
        href="https://twitter.com/intent/tweet/?text=Working%20with%20Custom%20Data%20Format%20in%20Rust%20using%20serde&amp;url=https%3a%2f%2fburaksekili.github.io%2farticles%2frust-serde%2f&amp;hashtags=Rust%2cserde">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Working with Custom Data Format in Rust using serde on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fburaksekili.github.io%2farticles%2frust-serde%2f&amp;title=Working%20with%20Custom%20Data%20Format%20in%20Rust%20using%20serde&amp;summary=Working%20with%20Custom%20Data%20Format%20in%20Rust%20using%20serde&amp;source=https%3a%2f%2fburaksekili.github.io%2farticles%2frust-serde%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Working with Custom Data Format in Rust using serde on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fburaksekili.github.io%2farticles%2frust-serde%2f&title=Working%20with%20Custom%20Data%20Format%20in%20Rust%20using%20serde">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Working with Custom Data Format in Rust using serde on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fburaksekili.github.io%2farticles%2frust-serde%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Working with Custom Data Format in Rust using serde on whatsapp"
        href="https://api.whatsapp.com/send?text=Working%20with%20Custom%20Data%20Format%20in%20Rust%20using%20serde%20-%20https%3a%2f%2fburaksekili.github.io%2farticles%2frust-serde%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Working with Custom Data Format in Rust using serde on telegram"
        href="https://telegram.me/share/url?text=Working%20with%20Custom%20Data%20Format%20in%20Rust%20using%20serde&amp;url=https%3a%2f%2fburaksekili.github.io%2farticles%2frust-serde%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Working with Custom Data Format in Rust using serde on ycombinator"
        href="https://news.ycombinator.com/submitlink?t=Working%20with%20Custom%20Data%20Format%20in%20Rust%20using%20serde&u=https%3a%2f%2fburaksekili.github.io%2farticles%2frust-serde%2f">
        <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
            xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
            <path
                d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://buraksekili.github.io/">Burak Sekili</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
