<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Thread Pooling in Rust  | Burak Sekili</title>
<meta name="keywords" content="Rust, concurrency">
<meta name="description" content="Explore the implementation and need for thread pools in Rust">
<meta name="author" content="Burak Sekili">
<link rel="canonical" href="https://buraksekili.github.io/articles/thread-pooling-rs/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.402aea8fcb16ea8922c350ac4593eaa9cc13e6c01b2c0f5fc06b1c73f528c213.css" integrity="sha256-QCrqj8sW6okiw1CsRZPqqcwT5sAbLA9fwGscc/UowhM=" rel="preload stylesheet" as="style">

<link rel="stylesheet" href="css/extended/custom.css">
<link rel="icon" href="https://buraksekili.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://buraksekili.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://buraksekili.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://buraksekili.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://buraksekili.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://buraksekili.github.io/articles/thread-pooling-rs/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-M6ZJTX7HVG"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-M6ZJTX7HVG');
        }
      </script><meta property="og:title" content="Thread Pooling in Rust " />
<meta property="og:description" content="Explore the implementation and need for thread pools in Rust" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://buraksekili.github.io/articles/thread-pooling-rs/" /><meta property="article:section" content="articles" />
<meta property="article:published_time" content="2024-09-06T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-09-07T00:39:28+03:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Thread Pooling in Rust "/>
<meta name="twitter:description" content="Explore the implementation and need for thread pools in Rust"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Articles",
      "item": "https://buraksekili.github.io/articles/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Thread Pooling in Rust ",
      "item": "https://buraksekili.github.io/articles/thread-pooling-rs/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Thread Pooling in Rust ",
  "name": "Thread Pooling in Rust ",
  "description": "Explore the implementation and need for thread pools in Rust",
  "keywords": [
    "Rust", "concurrency"
  ],
  "articleBody": "A thread pool is a software design pattern where a set of worker threads is created to execute tasks concurrently. Instead of creating a new thread for each task, which can be resource-intensive, tasks are submitted to the pool and executed by available worker threads.\nThis blog post will go through a simple thread pool implementation - similar to the one in Rust book - with a couple of simple enhancements.\nUnlike Go’s lightweight goroutines, Rust’s threads map directly to OS threads, making thread pools widely used technique for resource management and performance optimization.\nAt its core, a thread pool is a collection of worker threads that are ready to execute given tasks. Instead of spawning a new thread for each task - potentially costly operation in Rust - tasks are submitted to the pool and executed by available workers (threads). This pattern is useful in various scenarios: web servers handling multiple client connections, task scheduling systems processing queued jobs, parallel data processing applications crunching large datasets, I/O-bound applications managing concurrent operations, and more.\nThere are various benefits of thread pools. They offer resource management by limiting the number of active threads, preventing system resource exhaustion. Performance may be optimized as the overhead of repeated thread creation and destruction is eliminated. Thread pools also allow for predictable resource consumption, enabling developers to control and forecast the maximum thread usage. Load balancing comes as a natural consequence, with tasks distributed evenly across available threads.\nHowever, thread pools are not without their challenges.\nIntroducing additional complexity to the codebase, requiring careful management of shared state and synchronization to avoid pitfalls like deadlocks and race conditions, For very short-lived tasks, the overhead of task submission might outweigh the benefits. This means that sometimes if your task is not long-running or not compute expensive, sending this execution to another thread might be longer than the time spent on preparation of the task and sending it to a thread. Let’s say a task takes 1 ms to execute directly. If the overhead of submitting to and retrieving from the thread pool takes 10 ms, you’re spending 11 ms total instead of just 1. Determining the optimal pool size can be a tricky process as well. Contention or starvation may happen. For instance, while workers are busy with long running tasks, shorter tasks are waiting in line for a long time. In the context of Rust, additional language-specific considerations arise. The ownership system and Rust’s memory safety guarantees require careful implementation - that’s why I wanted to implement the pooling from scratch. It helped me to practice concurrency practices in Rust while considering ownership model.\nNow, let’s start implementing a thread pool in Rust.\nImplementation Please read Rust book’s thread pool section if you haven’t read before: https://rust-book.cs.brown.edu/ch20-02-multithreaded.html\nOur thread pool, as explained above, will have already initialized threads which are ready to execute a task. Here, we will use Worker to represents an individual thread in our pool.\nWorker Each worker runs in its own thread, continuously polling for jobs. Its purpose is to process the given jobs.\nYou may ask who gives the task to worker. Worker will poll the jobs from a queue which will be shared among all other workers. If no jobs are available, the worker needs to wait until another task is submitted to queue.\n1 2 3 4 5 6 7 8 struct Worker { // id corresponds to the arbitrary id for the thread // useful while debugging :) id: usize, // thread is the actual thread which is going // to execute a real task. thread: Option\u003cthread::JoinHandle\u003c()\u003e\u003e, } So, the requirements that we expect from the worker:\nIt will execute the task in its thread, Thread is part of Worker struct. So, we need to somehow implement a logic to get the task. We cannot store the task in Worker struct as the same thread (or Worker) can be reused after executing its task - this is the idea of the thread pooling. Thread safe queue to pull the tasks. It will be part of the constructor of the Worker. So that, when we spawn the thread, we also start listening this queue. The queue needs to be shared among all workers. That’s why it needs to be thread-safe. While creating a Worker, we will use std::thread and spawn the thread. In the closure of the thread, we will run our logic to pull tasks from the queue.\nIf there is a task on the queue, the thread will execute the task, and then waits for a next task to be scheduled for itself. As Worker needs to re-run tasks after executing a single one, it needs to run continous loop in order not to miss any task pushed into queue.\nIf no task is provided, the queue will return None. In that case, the thread needs to wait for next task to be scheduled. Therefore, thread needs to wait within the loop.\nThere are various way to do that but most simple one is sleeping. However, sleeping leads to busy-waiting which wastes CPU cycles. Also, if there are new tasks registered while the thread is sleeping, the worker will run the thread after a duration of sleep which causes a latency.\nInstead of sleeping, we will use Condvar which is a synchronisation primitive to allow threads to wait for some condition to become true. It’s often used in conjunction with a Mutex to provide a way for threads to efficiently wait for changes in shared state. So, we will use Condvar to wait for new tasks to be available as it allows immediate response when the job is available which improves thread utilization.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 impl Worker { fn new( id: usize, job_queue: Arc\u003cSegQueue\u003cJob\u003e\u003e, job_signal: Arc\u003c(Mutex\u003cbool\u003e, Condvar)\u003e, running: Arc\u003cAtomicBool\u003e, ) -\u003e Worker { let thread = thread::spawn(move || loop { match job_queue.pop() { Some(Job::Task(task)) =\u003e if let Err(_) = task() {}, Some(Job::Shutdown) =\u003e { break; } None =\u003e { let (lock, cvar) = \u0026*job_signal; let mut job_available = lock.lock().unwrap(); while !*job_available \u0026\u0026 running.load(Ordering::Relaxed) { job_available = cvar .wait_timeout(job_available, Duration::from_millis(100)) .unwrap() .0; } *job_available = false; } } }); Worker { id, thread: Some(thread), } } } Our queue depends on crossbeam’s crossbeam_queue::SegQueue which is a concurrent queue implementation. It’s designed for high-performance concurrent scenarios. Also, it is lock-free which is an important aspect of SegQueue.\nOur queue is actually a linked list of Job which will look like following:\n1 2 3 4 pub enum Job { Task(Box\u003cdyn FnOnce() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e + Send + 'static\u003e), Shutdown, } Job has two possible values, Task and Shutdown.\nThe Shutdown job type allows us to break the loop and terminate the thread gracefully. If a thread receives a Shutdown from the queue, it will stop executing.\nOkay, now check the Task. I know it looks too complicated at first glance, it still looks complicated to me. I’ll try to break it down.\nBox Result\u003c(), Box\u003e + Send + 'static\u003e Here we have two main parts; the FnOnce() and the return type of this closure, Box\u003e + Send + 'static\nFnOnce(): It is a closure without taking any arguments. It is same as thread::spawn(|| {}) closure. helps us to prevent accidentally call a task multiple times when it’s not safe to do so. -\u003e Result\u003c(), Box\u003e is the return type of this closure. On success, it returns () (unit, or void). On error, it returns a boxed trait object of std::error::Error. Trait object is one of the ways in Rust to write polymorphic code. Especially, dynamic dispatch uses trait objects to resolve generic function calls at runtime.\nBox: Box is used for heap allocation. dyn indicates a trait object, allowing for dynamic dispatch. Send: is a trait which ensures the closure can be safely sent between threads. 'static: is a lifetime bound ensuring the closure doesn’t contain any non-static references. 'static bound ensures a type is safe to use without lifetime constraints. Without 'static, we might create closures that reference stack-local variables, leading to use-after-free bugs. In the arguments of Worker::new method, the use of Arc allows safe sharing of the job queue and signaling mechanism between threads. This is crucial in Rust’s ownership model for concurrent programming. Otherwise, shared data cannot be used safely among multiple threads as it will cause lots of critical bugs.\nThread Pool 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 pub struct ThreadPool { // workers keep track of all worker threads. workers: Vec\u003cWorker\u003e, // job_queue corresponds to a shared queue for distributing jobs to workers. job_queue: Arc\u003cSegQueue\u003cJob\u003e\u003e, // job_signal is notifier for workers when new jobs are available. job_signal: Arc\u003c(Mutex\u003cbool\u003e, Condvar)\u003e, // running indicates whether the threadpool is actively running or not. // it is mainly checked by worker threads to understand the status // of the pool. running: Arc\u003cAtomicBool\u003e, } impl ThreadPool { pub fn new(size: usize) -\u003e ThreadPool { assert!(size \u003e 0); let job_queue = Arc::new(SegQueue::new()); let job_signal = Arc::new((Mutex::new(false), Condvar::new())); let mut workers = Vec::with_capacity(size); let running = Arc::new(AtomicBool::new(true)); for id in 0..size { workers.push(Worker::new( id, Arc::clone(\u0026job_queue), Arc::clone(\u0026job_signal), Arc::clone(\u0026running), )); } ThreadPool { workers, job_queue, job_signal, running, } } pub fn execute\u003cF\u003e(\u0026self, f: F) -\u003e Result\u003c(), ThreadPoolError\u003e where F: FnOnce() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e + Send + 'static, { // We create a new Job::Task, wrapping our closure 'f' let job = Job::Task(Box::new(f)); // Push this job to our queue self.job_queue.push(job); // Signal that a new job is available let (lock, cvar) = \u0026*self.job_signal; let mut job_available = lock.lock().unwrap(); *job_available = true; cvar.notify_all(); Ok(()) } } ThreadPool::new creates a fixed number of workers, each with shared access to the job queue and signaling mechanism.\nThreadPool::execute takes a generic parameter called F which implements FnOnce() -\u003e Result\u003c(), Box\u003e + Send + 'static. This type is the same type used for Job::Task - so that we can use argument f as Job. The argument passed in execute is actually a task that needs to be run in any of the workers.\nFor example,\n1 2 3 4 5 let x = 3; pool.execute(move || { println!(\"the task is running with value {}\", x); Ok(()) }) The execute will take closure function as argument and we wrap the user’s closure , which is argument f: F in ThreadPool::execute in Job::Task because:\nIt allows us to send different types of jobs through the same queue. Workers can distinguish between actual tasks and shutdown signals. It provides a uniform type (or interface if you are familiar with interfaces in other languages) for our job queue. All items in the queue are of type Job, regardless of the closure they contain. But, why do we use Box? The Box is crucial here for several reasons:\nWe are using dyn FnOnce() which is a trait object. In Rust, trait objects must be behind a pointer, and Box provides this. Closures can capture variables from their environment - as we did in the example above - which makes their size unknown at compile time. Box puts the closure on the heap, giving it a known size (the size of a pointer) at compile time. Box allows us to take ownership of the closure and move it into the Job enum, which is necessary because the closure will be executed in a different thread. This design actually allows us to:\nHandle different types of jobs (tasks and shutdown signals) uniformly. Move closures between threads safely, respecting Rust’s ownership rules. Deal with closures of different sizes and types in a unified manner. Graceful Shutdown 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 impl ThreadPool { pub fn shutdown(\u0026mut self, timeout: Duration) -\u003e Result\u003c(), ThreadPoolError\u003e { let start = Instant::now(); // Step 1: Signal all workers to stop self.running.store(false, Ordering::SeqCst); // Step 2: Wake up all waiting threads let (lock, cvar) = \u0026*self.job_signal; match lock.try_lock() { Ok(mut job_available) =\u003e { *job_available = true; cvar.notify_all(); } Err(_) =\u003e { // We couldn't acquire the lock, but we've set running to false, // so workers will eventually notice println!(\"Warning: Couldn't acquire lock to notify workers. They will exit on their next timeout check.\"); } } // Step 3: Wait for all workers to finish for worker in \u0026mut self.workers { if let Some(thread) = worker.thread.take() { // Step 4: Calculate remaining time let remaining = timeout .checked_sub(start.elapsed()) .unwrap_or(Duration::ZERO); // Step 5: Check if we've exceeded the timeout if remaining.is_zero() { return Err(ThreadPoolError::ShutdownTimeout); } // Step 6: Wait for the worker to finish if thread.join().is_err() { return Err(ThreadPoolError::ThreadJoinError(format!( \"Worker {} failed to join\", worker.id ))); } } } // Step 7: Final timeout check if start.elapsed() \u003e timeout { Err(ThreadPoolError::ShutdownTimeout) } else { Ok(()) } } } To notify workers polling the queue, we set the running flag to false. This is an atomic operation that immediately signals all workers that a shutdown is in progress. Since all threads need to finish executing the task they assigned to or stop waiting for next job (through cvar.wait_timeout method in Worker::new method) for proper shutdown, job_available is set to true, which triggers all threads and we notify all threads waiting on the condition variable.\nWe use try_lock() instead of lock() while notifying the threads. This attempts to acquire the lock but returns immediately if it can’t, rather than waiting until acquiring the lock.\nIf the lock is acquired, we proceed as before: set job_available to true and notify all waiting threads. By doing that, we can ensure that idle workers that were waiting on cvar.wait_timeout will wake up and notice the shutdown signal.\nIf the lock is not acquire successfully, the shutdown process continues. As running is already set to false, which all workers check periodically and wait_timeout in Worker’s main loop will expire - so they’ll wake up eventually and notice that running is false.\nAfter sending signals to notify threads, then we iterate through all workers, attempting to join each thread. Before joining each thread, the remaining time is calculated based on our timeout. This ensures we respect the overall timeout even if a worker is stuck (e.g., in an infinite loop), the timeout ensures we don’t wait forever.\nTo use shutdown method explicitly, the Drop can be implemented where the shutdown method can be triggered whenver ThreadPool is dropped, such as ThreadPool variable going out of scope.\n1 2 3 4 5 6 7 impl Drop for ThreadPool { fn drop(\u0026mut self) { if !self.workers.is_empty() { let _ = self.shutdown(Duration::from_secs(2)); } } } Implementing a thread pool in Rust offers a great opportunity to practice Rust’s concurrency and memory safety paradigms. Throughout this blog post, I’ve tried to explain some concepts such as atomic operations, condition variables, and Rust’s ownership system in a practical context. While the implementation provides a solid foundation, there’s always room for improvement and optimization - so, ofc not use it on anywhere :) There are plenty of great crates including crossbeam’s. I just developed this thread pooling to practice concepts aforementioned. Consider exploring advanced features like work stealing algorithms or dynamic pool sizing to further enhance performance.\nIf you notice any mistakes or have feedback, feel free to reach out to me on Twitter, LinkedIn, or GitHub.\nReferences https://doc.rust-lang.org/book/ch20-02-multithreaded.html https://github.com/crossbeam-rs/crossbeam ",
  "wordCount" : "2651",
  "inLanguage": "en",
  "datePublished": "2024-09-06T00:00:00Z",
  "dateModified": "2024-09-07T00:39:28+03:00",
  "author":{
    "@type": "Person",
    "name": "Burak Sekili"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://buraksekili.github.io/articles/thread-pooling-rs/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Burak Sekili",
    "logo": {
      "@type": "ImageObject",
      "url": "https://buraksekili.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://buraksekili.github.io/" accesskey="h" title="Burak Sekili (Alt + H)">Burak Sekili</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://buraksekili.github.io/archives/" title="Articles">
                    <span>Articles</span>
                </a>
            </li>
            <li>
                <a href="https://buraksekili.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://buraksekili.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://buraksekili.github.io/articles/">Articles</a></div>
    <h1 class="post-title">
      Thread Pooling in Rust 
    </h1>
    <div class="post-description">
      Explore the implementation and need for thread pools in Rust
    </div>
    <div class="post-meta"><span title='2024-09-06 00:00:00 +0000 UTC'>September 6, 2024</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Burak Sekili
</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#implementation" aria-label="Implementation">Implementation</a><ul>
                        
                <li>
                    <a href="#worker" aria-label="Worker">Worker</a></li>
                <li>
                    <a href="#thread-pool" aria-label="Thread Pool">Thread Pool</a></li>
                <li>
                    <a href="#graceful-shutdown" aria-label="Graceful Shutdown">Graceful Shutdown</a></li></ul>
                </li>
                <li>
                    <a href="#references" aria-label="References">References</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>A thread pool is a software design pattern where a set of worker threads is created to execute tasks concurrently.
Instead of creating a new thread for each task, which can be resource-intensive, tasks are submitted to the pool and executed by available worker threads.</p>
<p>This blog post will go through a simple thread pool implementation - similar to the one in Rust book - with
a couple of simple enhancements.</p>
<p>Unlike Go&rsquo;s lightweight goroutines, Rust&rsquo;s threads map directly to OS threads, making thread pools widely used
technique for resource management and performance optimization.</p>
<p>At its core, a thread pool is a collection of worker threads that are ready to execute given tasks.
Instead of spawning a new thread for each task - potentially costly operation in Rust - tasks are
submitted to the pool and executed by available workers (threads).
This pattern is useful in various scenarios: web servers handling multiple client connections,
task scheduling systems processing queued jobs, parallel data processing applications crunching large datasets,
I/O-bound applications managing concurrent operations, and more.</p>
<p>There are various benefits of thread pools. They offer resource management by limiting the number of
active threads, preventing system resource exhaustion.
Performance may be optimized as the overhead of repeated thread creation and destruction is eliminated.
Thread pools also allow for predictable resource consumption, enabling developers to control and forecast the maximum thread usage.
Load balancing comes as a natural consequence, with tasks distributed evenly across available threads.</p>
<p>However, thread pools are not without their challenges.</p>
<ul>
<li>Introducing additional complexity to the codebase, requiring careful management of shared state
and synchronization to avoid pitfalls like deadlocks and race conditions,</li>
<li>For very short-lived tasks, the overhead of task submission might outweigh the benefits.
<ul>
<li>This means that sometimes if your task is not long-running or not compute expensive,
sending this execution to another thread might be longer than the time spent on preparation
of the task and sending it to a thread.</li>
<li>Let&rsquo;s say a task takes 1 ms to execute directly. If the overhead of submitting to and retrieving
from the thread pool takes 10 ms, you&rsquo;re spending 11 ms total instead of just 1.</li>
<li>Determining the optimal pool size can be a tricky process as well.</li>
<li>Contention or starvation may happen. For instance, while workers are busy with long running tasks,
shorter tasks are waiting in line for a long time.</li>
</ul>
</li>
</ul>
<p>In the context of Rust, additional language-specific considerations arise. The ownership system and
Rust&rsquo;s memory safety guarantees require careful implementation - that&rsquo;s why I wanted to implement
the pooling from scratch. It helped me to practice concurrency practices in Rust while considering
ownership model.</p>
<p>Now, let&rsquo;s start implementing a thread pool in Rust.</p>
<h2 id="implementation">Implementation<a hidden class="anchor" aria-hidden="true" href="#implementation">#</a></h2>
<blockquote>
<p>Please read Rust book&rsquo;s thread pool section if you haven&rsquo;t read before: <a href="https://rust-book.cs.brown.edu/ch20-02-multithreaded.html">https://rust-book.cs.brown.edu/ch20-02-multithreaded.html</a></p>
</blockquote>
<p>Our thread pool, as explained above, will have already initialized threads which are ready to execute
a task. Here, we will use <code>Worker</code> to represents an individual thread in our pool.</p>
<h3 id="worker">Worker<a hidden class="anchor" aria-hidden="true" href="#worker">#</a></h3>
<p>Each worker runs in its own thread, continuously polling for jobs. Its purpose is to process the given
jobs.</p>
<p>You may ask who gives the task to worker. Worker will poll the jobs from a queue which will be
shared among all other workers. If no jobs are available, the worker needs to wait until another task
is submitted to queue.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Worker</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// id corresponds to the arbitrary id for the thread
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// useful while debugging :)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">id</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// thread is the actual thread which is going
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// to execute a real task.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">thread</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="n">thread</span>::<span class="n">JoinHandle</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>So, the requirements that we expect from the worker:</p>
<ul>
<li>It will execute the task in its thread,
<ul>
<li>Thread is part of Worker struct. So, we need to somehow implement a logic to get the task.</li>
<li>We cannot store the task in Worker struct as the same thread (or Worker) can be reused
after executing its task - this is the idea of the thread pooling.</li>
</ul>
</li>
<li>Thread safe queue to pull the tasks.
<ul>
<li>It will be part of the constructor of the Worker. So that, when we spawn the thread,
we also start listening this queue.</li>
<li>The queue needs to be shared among all workers. That&rsquo;s why it needs to be thread-safe.</li>
</ul>
</li>
</ul>
<p>While creating a Worker, we will use <code>std::thread</code> and spawn the thread.
In the closure of the thread, we will run our logic to pull tasks from the queue.</p>
<p>If there is a task on the queue, the thread will execute the task, and then waits
for a next task to be scheduled for itself. As Worker needs to re-run tasks after
executing a single one, it needs to run continous loop in order not to miss any
task pushed into queue.</p>
<p>If no task is provided, the queue will return <code>None</code>. In that case, the thread
needs to wait for next task to be scheduled. Therefore, thread needs to wait within
the loop.</p>
<p>There are various way to do that but most simple one is sleeping.
However, sleeping leads to busy-waiting which wastes CPU cycles. Also,
if there are new tasks registered while the thread is sleeping, the worker
will run the thread after a duration of sleep which causes a latency.</p>
<p>Instead of sleeping, we will use <code>Condvar</code> which is a synchronisation primitive
to allow threads to wait for some condition to become true. It&rsquo;s often used in
conjunction with a <code>Mutex</code> to provide a way for threads to efficiently wait for
changes in shared state. So, we will use <code>Condvar</code> to wait for new tasks to be
available as it allows immediate response when the job is available which
improves thread utilization.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">impl</span><span class="w"> </span><span class="n">Worker</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">id</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">job_queue</span>: <span class="nc">Arc</span><span class="o">&lt;</span><span class="n">SegQueue</span><span class="o">&lt;</span><span class="n">Job</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">job_signal</span>: <span class="nc">Arc</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">Condvar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">running</span>: <span class="nc">Arc</span><span class="o">&lt;</span><span class="n">AtomicBool</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Worker</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">thread</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">match</span><span class="w"> </span><span class="n">job_queue</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="nb">Some</span><span class="p">(</span><span class="n">Job</span>::<span class="n">Task</span><span class="p">(</span><span class="n">task</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">task</span><span class="p">()</span><span class="w"> </span><span class="p">{},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="nb">Some</span><span class="p">(</span><span class="n">Job</span>::<span class="n">Shutdown</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">break</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">lock</span><span class="p">,</span><span class="w"> </span><span class="n">cvar</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;*</span><span class="n">job_signal</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">job_available</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">while</span><span class="w"> </span><span class="o">!*</span><span class="n">job_available</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">running</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">Ordering</span>::<span class="n">Relaxed</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="n">job_available</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cvar</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                            </span><span class="p">.</span><span class="n">wait_timeout</span><span class="p">(</span><span class="n">job_available</span><span class="p">,</span><span class="w"> </span><span class="n">Duration</span>::<span class="n">from_millis</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                            </span><span class="p">.</span><span class="n">unwrap</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                            </span><span class="p">.</span><span class="mi">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="o">*</span><span class="n">job_available</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Worker</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">id</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">thread</span>: <span class="nb">Some</span><span class="p">(</span><span class="n">thread</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Our queue depends on <code>crossbeam</code>&rsquo;s <code>crossbeam_queue::SegQueue</code> which is a concurrent
queue implementation. It&rsquo;s designed for high-performance concurrent scenarios. Also,
it is lock-free which is an important aspect of <code>SegQueue</code>.</p>
<p>Our queue is actually a linked list of <code>Job</code> which will look like following:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">Job</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Task</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="nb">FnOnce</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span>::<span class="n">Error</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="o">&gt;</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Shutdown</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Job has two possible values, <code>Task</code> and <code>Shutdown</code>.</p>
<p>The <code>Shutdown</code> job type allows us to break the loop and terminate the thread gracefully.
If a thread receives a <code>Shutdown</code> from the queue, it will stop executing.</p>
<p>Okay, now check the <code>Task</code>. I know it looks too complicated at first glance, it still
looks complicated to me. I&rsquo;ll try to break it down.</p>
<ul>
<li><code>Box&lt;dyn FnOnce() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; + Send + 'static&gt;</code></li>
</ul>
<p>Here we have two main parts; the <code>FnOnce()</code> and the return type of this closure,
<code>Box&lt;dyn std::error::Error&gt;&gt; + Send + 'static</code></p>
<ul>
<li><code>FnOnce()</code>:
<ul>
<li>It is a closure without taking any arguments. It is same as <code>thread::spawn(|| {})</code>
closure.</li>
<li>helps us to prevent accidentally call a task multiple times when
it&rsquo;s not safe to do so.</li>
<li><code>-&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt;</code> is the return type of this closure.
On success, it returns <code>()</code> (unit, or void). On error, it returns a boxed trait object
of <code>std::error::Error</code>.</li>
</ul>
</li>
</ul>
<blockquote>
<p>Trait object is one of the ways in Rust to write polymorphic code. Especially, dynamic
dispatch uses trait objects to resolve generic function calls at runtime.</p>
</blockquote>
<ul>
<li><code>Box&lt;dyn ...&gt;</code>: Box is used for heap allocation. <code>dyn</code> indicates a trait object,
allowing for dynamic dispatch.</li>
<li><code>Send</code>: is a trait which ensures the closure can be safely sent between threads.</li>
<li><code>'static</code>: is a lifetime bound ensuring the closure doesn&rsquo;t contain any
non-static references. <code>'static</code> bound ensures a type is safe to use without
lifetime constraints. Without <code>'static</code>, we might create closures that reference
stack-local variables, leading to use-after-free bugs.</li>
</ul>
<p>In the arguments of <code>Worker::new</code> method, the use of <code>Arc</code> allows safe sharing of the job queue
and signaling mechanism between threads.
This is crucial in Rust&rsquo;s ownership model for concurrent programming.
Otherwise, shared data cannot be used safely among multiple threads as it will cause lots of critical bugs.</p>
<h3 id="thread-pool">Thread Pool<a hidden class="anchor" aria-hidden="true" href="#thread-pool">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">ThreadPool</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// workers keep track of all worker threads.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">workers</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Worker</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// job_queue corresponds to a shared queue for distributing jobs to workers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">job_queue</span>: <span class="nc">Arc</span><span class="o">&lt;</span><span class="n">SegQueue</span><span class="o">&lt;</span><span class="n">Job</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// job_signal is notifier for workers when new jobs are available.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">job_signal</span>: <span class="nc">Arc</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">Condvar</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// running indicates whether the threadpool is actively running or not.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// it is mainly checked by worker threads to understand the status
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// of the pool.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">running</span>: <span class="nc">Arc</span><span class="o">&lt;</span><span class="n">AtomicBool</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">ThreadPool</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">size</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">ThreadPool</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="fm">assert!</span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">job_queue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">new</span><span class="p">(</span><span class="n">SegQueue</span>::<span class="n">new</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">job_signal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">new</span><span class="p">((</span><span class="n">Mutex</span>::<span class="n">new</span><span class="p">(</span><span class="kc">false</span><span class="p">),</span><span class="w"> </span><span class="n">Condvar</span>::<span class="n">new</span><span class="p">()));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">workers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">with_capacity</span><span class="p">(</span><span class="n">size</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">running</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">new</span><span class="p">(</span><span class="n">AtomicBool</span>::<span class="n">new</span><span class="p">(</span><span class="kc">true</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">size</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">workers</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Worker</span>::<span class="n">new</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">id</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Arc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">job_queue</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Arc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">job_signal</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Arc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">running</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">ThreadPool</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">workers</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">job_queue</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">job_signal</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">running</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">execute</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">ThreadPoolError</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">where</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">F</span>: <span class="nb">FnOnce</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span>::<span class="n">Error</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// We create a new Job::Task, wrapping our closure &#39;f&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">job</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Job</span>::<span class="n">Task</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">f</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Push this job to our queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">job_queue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">job</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Signal that a new job is available
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">lock</span><span class="p">,</span><span class="w"> </span><span class="n">cvar</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;*</span><span class="bp">self</span><span class="p">.</span><span class="n">job_signal</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">job_available</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="o">*</span><span class="n">job_available</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">cvar</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>ThreadPool::new</code> creates a fixed number of workers,
each with shared access to the job queue and signaling mechanism.</p>
<p><code>ThreadPool::execute</code> takes a generic parameter called <code>F</code> which implements
<code>FnOnce() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; + Send + 'static</code>. This type
is the same type used for <code>Job::Task</code> - so that we can use argument <code>f</code> as <code>Job</code>.
The argument passed in <code>execute</code> is actually a task that needs to be run in any of the workers.</p>
<p>For example,</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">pool</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;the task is running with value </span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">})</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>The <code>execute</code> will take closure function as argument and we wrap the user&rsquo;s closure
, which is argument <code>f: F</code> in <code>ThreadPool::execute</code> in <code>Job::Task</code> because:</p>
<ul>
<li>It allows us to send different types of jobs through the same queue. Workers can
distinguish between actual tasks and shutdown signals.</li>
<li>It provides a uniform type (or interface if you are familiar
with interfaces in other languages) for our job queue.
All items in the queue are of type <code>Job</code>, regardless of the closure they contain.</li>
</ul>
<p>But, why do we use <code>Box</code>? The <code>Box</code> is crucial here for several reasons:</p>
<ul>
<li>We are using <code>dyn FnOnce()</code> which is a trait object.
In Rust, trait objects must be behind a pointer, and <code>Box</code> provides this.</li>
<li>Closures can capture variables from their environment - as we did in the example above -
which makes their size unknown at compile time. Box puts the closure on the heap,
giving it a known size (the size of a pointer) at compile time.</li>
<li>Box allows us to take ownership of the closure and move it into the <code>Job</code> enum,
which is necessary because the closure will be executed in a different thread.</li>
</ul>
<p>This design actually allows us to:</p>
<ul>
<li>Handle different types of jobs (tasks and shutdown signals) uniformly.</li>
<li>Move closures between threads safely, respecting Rust&rsquo;s ownership rules.</li>
<li>Deal with closures of different sizes and types in a unified manner.</li>
</ul>
<h3 id="graceful-shutdown">Graceful Shutdown<a hidden class="anchor" aria-hidden="true" href="#graceful-shutdown">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">impl</span><span class="w"> </span><span class="n">ThreadPool</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">shutdown</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">timeout</span>: <span class="nc">Duration</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">ThreadPoolError</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Instant</span>::<span class="n">now</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Step 1: Signal all workers to stop
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">running</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">SeqCst</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Step 2: Wake up all waiting threads
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">lock</span><span class="p">,</span><span class="w"> </span><span class="n">cvar</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;*</span><span class="bp">self</span><span class="p">.</span><span class="n">job_signal</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">lock</span><span class="p">.</span><span class="n">try_lock</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nb">Ok</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">job_available</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="o">*</span><span class="n">job_available</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">cvar</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="c1">// We couldn&#39;t acquire the lock, but we&#39;ve set running to false,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">                </span><span class="c1">// so workers will eventually notice
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">                </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Warning: Couldn&#39;t acquire lock to notify workers. They will exit on their next timeout check.&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Step 3: Wait for all workers to finish
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">worker</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">workers</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">thread</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">worker</span><span class="p">.</span><span class="n">thread</span><span class="p">.</span><span class="n">take</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="c1">// Step 4: Calculate remaining time
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">timeout</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">.</span><span class="n">checked_sub</span><span class="p">(</span><span class="n">start</span><span class="p">.</span><span class="n">elapsed</span><span class="p">())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">.</span><span class="n">unwrap_or</span><span class="p">(</span><span class="n">Duration</span>::<span class="no">ZERO</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="c1">// Step 5: Check if we&#39;ve exceeded the timeout
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="n">remaining</span><span class="p">.</span><span class="n">is_zero</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">ThreadPoolError</span>::<span class="n">ShutdownTimeout</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="c1">// Step 6: Wait for the worker to finish
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="n">thread</span><span class="p">.</span><span class="n">join</span><span class="p">().</span><span class="n">is_err</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">ThreadPoolError</span>::<span class="n">ThreadJoinError</span><span class="p">(</span><span class="fm">format!</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="s">&#34;Worker </span><span class="si">{}</span><span class="s"> failed to join&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="n">worker</span><span class="p">.</span><span class="n">id</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">)));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Step 7: Final timeout check
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">start</span><span class="p">.</span><span class="n">elapsed</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">timeout</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="n">ThreadPoolError</span>::<span class="n">ShutdownTimeout</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>To notify workers polling the queue, we set the <code>running</code> flag to false.
This is an atomic operation that immediately signals all workers that a shutdown
is in progress.
Since all threads need to finish executing the task they assigned to or stop waiting
for next job (through <code>cvar.wait_timeout</code> method in <code>Worker::new</code> method) for proper shutdown,
<code>job_available</code> is set to true, which triggers all threads and we notify all threads waiting on the
condition variable.</p>
<p>We use <code>try_lock()</code> instead of <code>lock()</code> while notifying the threads.
This attempts to acquire the lock but returns immediately if it can&rsquo;t, rather than waiting until
acquiring the lock.</p>
<ul>
<li>
<p>If the lock is acquired, we proceed as before: set <code>job_available</code> to true and notify all waiting threads. By doing that, we can ensure that idle workers that were waiting
on <code>cvar.wait_timeout</code> will wake up and notice the shutdown signal.</p>
</li>
<li>
<p>If the lock is not acquire successfully, the shutdown process continues. As <code>running</code>
is already set to false, which all workers check periodically and
<code>wait_timeout</code> in <code>Worker</code>&rsquo;s main loop will expire - so they&rsquo;ll wake up eventually
and notice that <code>running</code> is false.</p>
</li>
</ul>
<p>After sending signals to notify threads, then we iterate through all workers,
attempting to join each thread. Before joining each thread, the remaining time is calculated based on our timeout.
This ensures we respect the overall timeout even if a worker is stuck (e.g., in an infinite loop), the timeout ensures we don&rsquo;t wait forever.</p>
<p>To use shutdown method explicitly, the <code>Drop</code> can be implemented where the shutdown
method can be triggered whenver <code>ThreadPool</code> is dropped, such as ThreadPool variable
going out of scope.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">impl</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">ThreadPool</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="bp">self</span><span class="p">.</span><span class="n">workers</span><span class="p">.</span><span class="n">is_empty</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">shutdown</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_secs</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Implementing a thread pool in Rust offers a great opportunity to practice Rust&rsquo;s concurrency and memory safety paradigms.
Throughout this blog post, I&rsquo;ve tried to explain some concepts
such as atomic operations, condition variables, and Rust&rsquo;s ownership system in a
practical context.
While the implementation provides a solid foundation, there&rsquo;s always room for improvement and optimization - so, ofc not use it on anywhere :)
There are plenty of great crates including <code>crossbeam</code>&rsquo;s. I just developed this thread pooling to practice concepts aforementioned.
Consider exploring advanced features like work stealing algorithms or dynamic pool sizing
to further enhance performance.</p>
<p>If you notice any mistakes or have feedback, feel free to reach out to me on
<a href="https://x.com/buraksekili">Twitter</a>, <a href="https://www.linkedin.com/in/sekili/">LinkedIn</a>, or GitHub.</p>
<h2 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch20-02-multithreaded.html">https://doc.rust-lang.org/book/ch20-02-multithreaded.html</a></li>
<li><a href="https://github.com/crossbeam-rs/crossbeam">https://github.com/crossbeam-rs/crossbeam</a></li>
</ul>


  </div>

  <footer class="post-footer">
    <div class="social-icons"><a class="edit-post-span"
    href="https://github.com/buraksekili/buraksekili.github.io/blob/main/content/articles/thread-pooling-rs.md"
    rel="noopener noreferrer" target="_blank">Edit this page on <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
        stroke-linecap="round" stroke-linejoin="round">
        <path
            d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22">
        </path>
    </svg>
</a></div>

    <ul class="post-tags">
      <li><a href="https://buraksekili.github.io/tags/rust/">Rust</a></li>
      <li><a href="https://buraksekili.github.io/tags/concurrency/">Concurrency</a></li>
    </ul>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Thread Pooling in Rust  on twitter"
        href="https://twitter.com/intent/tweet/?text=Thread%20Pooling%20in%20Rust%20&amp;url=https%3a%2f%2fburaksekili.github.io%2farticles%2fthread-pooling-rs%2f&amp;hashtags=Rust%2cconcurrency">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Thread Pooling in Rust  on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fburaksekili.github.io%2farticles%2fthread-pooling-rs%2f&amp;title=Thread%20Pooling%20in%20Rust%20&amp;summary=Thread%20Pooling%20in%20Rust%20&amp;source=https%3a%2f%2fburaksekili.github.io%2farticles%2fthread-pooling-rs%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Thread Pooling in Rust  on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fburaksekili.github.io%2farticles%2fthread-pooling-rs%2f&title=Thread%20Pooling%20in%20Rust%20">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Thread Pooling in Rust  on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fburaksekili.github.io%2farticles%2fthread-pooling-rs%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Thread Pooling in Rust  on whatsapp"
        href="https://api.whatsapp.com/send?text=Thread%20Pooling%20in%20Rust%20%20-%20https%3a%2f%2fburaksekili.github.io%2farticles%2fthread-pooling-rs%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Thread Pooling in Rust  on telegram"
        href="https://telegram.me/share/url?text=Thread%20Pooling%20in%20Rust%20&amp;url=https%3a%2f%2fburaksekili.github.io%2farticles%2fthread-pooling-rs%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Thread Pooling in Rust  on ycombinator"
        href="https://news.ycombinator.com/submitlink?t=Thread%20Pooling%20in%20Rust%20&u=https%3a%2f%2fburaksekili.github.io%2farticles%2fthread-pooling-rs%2f">
        <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
            xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
            <path
                d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://buraksekili.github.io/">Burak Sekili</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
